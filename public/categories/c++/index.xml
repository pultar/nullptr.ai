<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on nullptr.ai</title>
    <link>https://nullptr.ai/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on nullptr.ai</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 30 Jan 2023 12:00:00 +0000</lastBuildDate>
    <atom:link href="https://nullptr.ai/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link>https://nullptr.ai/blog/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 30 Jan 2023 12:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/3-longest-substring-without-repeating-characters/</guid>
      <description>Problem Statement The problem is taken from LeetCode.&#xA;Initial Solution: Hash Set and Sliding Window Instead of going through the std::string multiple times, we use the sliding window technique. We keep track of a global max, as well as two pointers low and high, all initialized to 0.</description>
    </item>
    <item>
      <title>542. 01 Matrix</title>
      <link>https://nullptr.ai/blog/542-01-matrix/</link>
      <pubDate>Wed, 25 Jan 2023 11:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/542-01-matrix/</guid>
      <description>Problem Statement The problem is taken from LeetCode.&#xA;First Solution - Breadth-First Search Computing closest distances in a matrix should always trigger BFS. We initialize a std::vector for the computed distances results. There is two ways we can go about performing BFS: either we start from all 1&#39;s and try to find the closest 0, or we start from all 0&#39;s and try to find all 1&#39;s.</description>
    </item>
    <item>
      <title>57. Insert Interval</title>
      <link>https://nullptr.ai/blog/57-insert-interval/</link>
      <pubDate>Wed, 25 Jan 2023 11:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/57-insert-interval/</guid>
      <description>The Problem Statement This problem is taken from LeetCode.&#xA;The Solution We will allocate a new std::vector and reserve a capacity of intervals.size() + 1. We loop over all intervals and during each step check if the end of the newInterval is smaller than the head of the current interval.</description>
    </item>
    <item>
      <title>53. Maximum Subarray</title>
      <link>https://nullptr.ai/blog/53-maximum-subarray/</link>
      <pubDate>Tue, 24 Jan 2023 13:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/53-maximum-subarray/</guid>
      <description>The Problem Statement This problem is taken from LeetCode.&#xA;The Solution - Kadane&#39;s Algorithm It is very easy to end up with a solution that is $O(N^2)$ or $O(N^3)$ in time complexity by comparing all possible subarrays. The challenge is to find a solution that is only $O(N)$.</description>
    </item>
    <item>
      <title>217. Contains Duplicate</title>
      <link>https://nullptr.ai/blog/217-contains-duplicate/</link>
      <pubDate>Mon, 23 Jan 2023 20:59:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/217-contains-duplicate/</guid>
      <description>The Problem Statement This problem is taken from LeetCode.&#xA;First Solution: std::unordered_set In order to avoid quadratic time complexity resulting from comparing each pair of numbers, we can use a std::unordered_set&amp;lt;int&amp;gt;. We iterate once through all elements and check if the element in already in our set.</description>
    </item>
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://nullptr.ai/blog/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 23 Jan 2023 13:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/104-maximum-depth-of-binary-tree/</guid>
      <description>The Problem Statement The problem is taken from LeetCode.&#xA;First Solution: Recursive Depth-First Search I found it most straightforward to run a recursive depth-first search (DFS) on the tree. The intuition is that the maximum depth of any node is simply the maximum depth of either the left or the right half of the tree + 1.</description>
    </item>
    <item>
      <title>876. Middle of the Linked List</title>
      <link>https://nullptr.ai/blog/876-middle-of-the-linked-list/</link>
      <pubDate>Mon, 23 Jan 2023 12:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/876-middle-of-the-linked-list/</guid>
      <description>The Problem Statement The problem is taken from LeetCode.&#xA;First Solution: Na√Øve Copy to std::vector The underlying problem here is that linked lists don&#39;t have random access. If the data structure we operate on were a std::vector or std::array, we could simply calculate the middle via the size of the container.</description>
    </item>
    <item>
      <title>Evaluating Square Roots</title>
      <link>https://nullptr.ai/blog/evaluating-square-roots/</link>
      <pubDate>Mon, 23 Jan 2023 10:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/evaluating-square-roots/</guid>
      <description>The problem statement There is a LeetCode problem that asks you implement a sqrt function that returns the rounded-down nearest integer value. I am not aware, however, of a problem that asks you to simply reproduce the behavior of the standard library sqrt function.</description>
    </item>
    <item>
      <title>543. Diameter of Binary Tree</title>
      <link>https://nullptr.ai/blog/543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 23 Jan 2023 09:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/543-diameter-of-binary-tree/</guid>
      <description>The problem statement The problem is taken from LeetCode.&#xA;The solution We can write a helper function int dfs(TreeNode* root, int&amp;amp; max) that recursively computes the height of all possible subtrees. This algorithm is called depth-first search and quite common in tree and graph problems.</description>
    </item>
  </channel>
</rss>
