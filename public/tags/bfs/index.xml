<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on nullptr.ai</title>
    <link>https://nullptr.ai/tags/bfs/</link>
    <description>Recent content in bfs on nullptr.ai</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 25 Jan 2023 11:00:00 +0000</lastBuildDate>
    <atom:link href="https://nullptr.ai/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>542. 01 Matrix</title>
      <link>https://nullptr.ai/blog/542-01-matrix/</link>
      <pubDate>Wed, 25 Jan 2023 11:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/542-01-matrix/</guid>
      <description>Problem Statement The problem is taken from LeetCode.&#xA;First Solution - Breadth-First Search Computing closest distances in a matrix should always trigger BFS. We initialize a std::vector for the computed distances results. There is two ways we can go about performing BFS: either we start from all 1&#39;s and try to find the closest 0, or we start from all 0&#39;s and try to find all 1&#39;s.</description>
    </item>
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://nullptr.ai/blog/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 23 Jan 2023 13:00:00 +0000</pubDate>
      <guid>https://nullptr.ai/blog/104-maximum-depth-of-binary-tree/</guid>
      <description>The Problem Statement The problem is taken from LeetCode.&#xA;First Solution: Recursive Depth-First Search I found it most straightforward to run a recursive depth-first search (DFS) on the tree. The intuition is that the maximum depth of any node is simply the maximum depth of either the left or the right half of the tree + 1.</description>
    </item>
  </channel>
</rss>
