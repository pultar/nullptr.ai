<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name="hugo-theme" content="Axiom 0.8.0">



  <link rel="icon" type="image/png" sizes="32x32" href="/image/brand/favicon.png">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/image/brand/icon-1-1.png">
  <link rel="canonical" href="https://nullptr.ai/blog/876-middle-of-the-linked-list/">
<link rel="preload" as="style" href="/bundle.css?v=1703885521" media="all">
<link rel="stylesheet" href="/bundle.css?v=1703885521" media="all">
<style>.cdata pre{background-color:#1f2937;color:#e5e7eb}.cdata :not(pre)>code{background-color:#f3f4f6;color:#7c3aed}.chroma .err{background-color:#991b1b;color:#fecaca}.chroma .hl{background-color:#374151}.chroma .ln{color:#9ca3af}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr{color:#60a5fa}.chroma .kt{color:#a78bfa}.chroma .na,.chroma .nb{color:#fbbf24}.chroma .nc{color:#f87171}.chroma .no{color:#34d399}.chroma .nd{color:#f87171}.chroma .ne{color:#f87171}.chroma .nf{color:#fbbf24}.chroma .nt{color:#f87171}.chroma .l{color:#a78bfa}.chroma .dl,.chroma .ld,.chroma .s,.chroma .s2,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .sd{color:#34d399}.chroma .se{color:#9ca3af}.chroma .s1,.chroma .sh,.chroma .si,.chroma .sr,.chroma .ss,.chroma .sx{color:#34d399}.chroma .il,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .mo{color:#a78bfa}.chroma .o,.chroma .ow{color:#93c5fd}.chroma .c,.chroma .c1,.chroma .ch,.chroma .cm,.chroma .cp,.chroma .cpf,.chroma .cs,.chroma .p{color:#9ca3af}.chroma .ge{font-style:italic}.chroma .gs{font-weight:700}
</style>



<title>876. Middle of the Linked List : nullptr.ai</title>

<meta property="og:title" content="876. Middle of the Linked List">
<meta property="og:site_name" content="nullptr.ai">
<meta property="og:url" content="https://nullptr.ai/blog/876-middle-of-the-linked-list/">
<link rel="image_src" href="https://nullptr.ai/image/page-default.webp">
<meta property="og:image" content="https://nullptr.ai/image/page-default.webp">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:description" content="The Problem Statement The problem is taken from LeetCode. First Solution: Naïve Copy to std::vector The underlying problem here is that linked lists don&#39;t have random access. If the data structure we operate on were a std::vector or std::array, we could simply calculate the middle via the size of the container.">
<meta name="description" content="The Problem Statement The problem is taken from LeetCode. First Solution: Naïve Copy to std::vector The underlying problem here is that linked lists don&#39;t have random access. If the data structure we operate on were a std::vector or std::array, we could simply calculate the middle via the size of the container.">
<meta property="og:updated_time" content="2023-01-23T12:00:00Z">
<meta property="fb:app_id" content="">
<meta name="author" content="Felix Pultar">
<meta property="article:author" content="https://nullptr.ai/">
<meta property="article:published_time" content="2023-01-23T12:00:00Z">
<meta property="article:modified_time" content="2023-01-23T12:00:00Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "876. Middle of the Linked List",
  "alternativeHeadline": "Solving the problem of finding the middle of a linked list in C++.",
  "url": "https://nullptr.ai/blog/876-middle-of-the-linked-list/",
  "image": "https://nullptr.ai/image/page-default.webp",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nullptr.ai/blog/876-middle-of-the-linked-list/"
  },
  "description": "The Problem Statement The problem is taken from LeetCode. First Solution: Naïve Copy to std::vector The underlying problem here is that linked lists don't have random access. If the data structure we operate on were a std::vector or std::array, we could simply calculate the middle via the size of the container.",
  "author": {
    "@type": "Person",
    "name": "Felix Pultar"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nullptr.ai",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nullptr.ai/image/brand/icon-1-1.png"
    }
  },
  "datePublished": "2023-01-23T12:00:00Z",
  "dateModified": "2023-01-23T12:00:00Z",
  "articleBody": "\u003ch2 id=\"the-problem-statement\"\u003eThe Problem Statement\u003c/h2\u003e\n\u003cp\u003eThe problem is taken from \u003ca href=\"https://leetcode.com/problems/middle-of-the-linked-list/description/\"\u003eLeetCode\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"first-solution-naïve-copy-to-stdvector\"\u003eFirst Solution: Naïve Copy to std::vector\u003c/h2\u003e\n\u003cp\u003eThe underlying problem here is that linked lists don't have random access. If the data structure we operate on were a \u003ccode\u003estd::vector\u003c/code\u003e or \u003ccode\u003estd::array\u003c/code\u003e, we could simply calculate the middle via the size of the container. So why don't we just copy all elements of the list into a \u003ccode\u003estd::vector\u003c/code\u003e?\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * Definition for singly-linked list.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * struct ListNode {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     int val;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode *next;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode() : val(0), next(nullptr) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode(int x) : val(x), next(nullptr) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * };\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003emiddleNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// naive approach -\u0026gt; copy to vector\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eelements\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eelements\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eelements\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eelements\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis approach has $O(n)$ run time complexity as we have to iterate once over the list and $O(n)$ space complexity as we copy each element into a \u003ccode\u003estd::vector\u003c/code\u003e. It's worth noting though that we only copy pointers and not the underlying data. In this particular case, the linked list stores \u003ccode\u003eint\u003c/code\u003e and accordingly, this difference does not change anything. However, it's conceivable that the linked list stores big objects (e.g. a 3D mesh), which we would \u003cem\u003enot\u003c/em\u003e copy using this approach. In other words, it's potentially not as harmful to copy the data as the space complexity suggests. However, there is a better approach.\u003c/p\u003e\n\u003ch2 id=\"two-pointer-running-technique\"\u003eTwo-Pointer Running Technique\u003c/h2\u003e\n\u003cp\u003eOne way to avoid linear space complexity in this problem is the \u003cstrong\u003etwo-pointer running technique\u003c/strong\u003e. We will instantiate two pointers named \u003ccode\u003eslowRunner\u003c/code\u003e and \u003ccode\u003efastRunner\u003c/code\u003e that both initially point to the head node of the list. Subsequently, we will go through list once. In each iteration, \u003ccode\u003eslowRunner\u003c/code\u003e moves one node at a time and \u003ccode\u003efastRunner\u003c/code\u003e moves two nodes at a time. Once \u003ccode\u003efastRunner\u003c/code\u003e falls off the list, \u003ccode\u003eslowRunner\u003c/code\u003e points to the middle of the list.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * Definition for singly-linked list.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * struct ListNode {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     int val;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode *next;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode() : val(0), next(nullptr) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode(int x) : val(x), next(nullptr) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * };\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003emiddleNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// two-pointer running\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eslowRunner\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003efastRunner\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efastRunner\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003efastRunner\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eslowRunner\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eslowRunner\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003efastRunner\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efastRunner\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eslowRunner\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis solution also has $O(n)$ run time complexity but only $O(1)$ space complexity.\u003c/p\u003e"
}
</script>

<link rel="preload" as="script" href="/bundle.js?v=1703885521">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        });
    });
</script>
</head>
<body>

  <header id="nav" class="header">
  <div class="ax-l-i max-w-6xl">
    <div class="ax-logo">
      <a class="block" href="/" title="nullptr.ai"><svg viewBox="0 0 144 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<style type="text/css">
  .mark{fill:#b34d71;}
  .word{fill:#8b738c;}
</style>
<path class="mark" d="M121.527 30.625c.75.33 1.533.608 2.34.824l.63.154 8.895-5.135.952 1.65-6.717 3.878a15.89 15.89 0 0 0 8.377-2.143c3.68-2.11 6.365-5.6 7.452-9.71.215-.8.367-1.616.457-2.44l-22.386 12.923zM142.3 8.843l-9.562 5.52-.952-1.65 9.562-5.52a16.19 16.19 0 0 0-1.433-1.866L120.66 16.45l-.953-1.65 18.815-10.86c-.64-.56-1.322-1.065-2.043-1.514l-12.232 7.06-.952-1.65 11.192-6.46c-.75-.33-1.533-.608-2.34-.824-.208-.056-.418-.107-.628-.155L112.74 11.24l-.18.622a15.88 15.88 0 0 0 1.597 12.135c1.333 2.3 3.178 4.208 5.38 5.578L144 15.45a15.87 15.87 0 0 0-1.69-6.609v.001zm-6.113 18.204l-.952-1.65 2.595-1.498.952 1.65-2.595 1.498zm-9.877-8.973l-.952-1.65 4.573-2.64.952 1.65-4.573 2.64zM127.982 0c-2.8.002-5.55.744-7.97 2.15a15.89 15.89 0 0 0-6.045 6.183L128.39.006 127.982 0z"/>
<path class="word" d="M11.385 14.868c0-.998-.38-1.767-1.104-2.25s-1.725-.713-2.932-.713c-.932 0-1.794.142-2.588.427-.828.314-1.518.684-2.07 1.14l-1.725-1.7c.794-.627 1.794-1.112 2.967-1.482 1.138-.37 2.38-.54 3.726-.54 1.173 0 2.174.143 3.07.4.863.285 1.553.655 2.105 1.14s.966 1.026 1.242 1.68a5.27 5.27 0 0 1 .414 2.08v5.9l.07 1.425c0 .513.07.94.172 1.254H11.8c-.173-.655-.276-1.282-.276-1.938h-.103a6.06 6.06 0 0 1-2.243 1.68c-.93.4-2 .598-3.243.598-.655 0-1.3-.057-2-.2-.724-.142-1.346-.4-1.932-.712S.968 22.317.59 21.775C.172 21.224 0 20.568 0 19.8c0-1.026.345-1.853 1-2.45s1.553-1.055 2.622-1.368 2.3-.513 3.657-.598l4.105-.143v-.37zm-.793 2.3l-2.484.085c-.863.057-1.656.17-2.346.342-.724.17-1.3.428-1.76.77s-.7.798-.7 1.368c0 .4.104.74.3.998.172.256.45.485.76.656s.7.285 1.07.342c.38.085.794.114 1.208.114 1.518 0 2.7-.37 3.52-1.14.793-.74 1.207-1.68 1.207-2.822v-.712h-.793zm14.178-.658l-5.97-6.412h4.002l4.002 4.645 4.036-4.645h3.795l-5.9 6.384 6.6 7.125h-4.037l-4.554-5.273-4.623 5.273h-3.9l6.555-7.096zm17.77 7.098h-3.243V10.1h3.243v13.5zm.552-18.382a1.49 1.49 0 0 1-.621 1.226c-.45.314-.966.485-1.553.485s-1.104-.17-1.518-.513c-.414-.313-.62-.712-.62-1.197s.207-.912.62-1.254c.414-.314.93-.485 1.518-.485a2.64 2.64 0 0 1 1.553.485c.414.342.62.77.62 1.254zm22.528 11.6c0 1.055-.207 1.995-.656 2.88a6.71 6.71 0 0 1-1.863 2.252c-.828.656-1.76 1.14-2.83 1.482-1.07.37-2.243.54-3.485.54s-2.415-.17-3.485-.54c-1.07-.342-2-.826-2.794-1.482-.793-.627-1.38-1.368-1.828-2.25s-.7-1.824-.7-2.88.242-1.995.7-2.878a6.79 6.79 0 0 1 1.828-2.223c.794-.627 1.725-1.112 2.794-1.482 1.07-.342 2.243-.513 3.485-.513s2.415.17 3.485.513c1.07.37 2 .855 2.83 1.482a6.9 6.9 0 0 1 1.863 2.223c.45.883.656 1.824.656 2.878zm-3.38 0a4.81 4.81 0 0 0-.345-1.852c-.242-.598-.62-1.1-1.07-1.567a5.18 5.18 0 0 0-1.7-1.055c-.7-.257-1.483-.4-2.346-.4s-1.656.142-2.312.4c-.7.257-1.276.627-1.725 1.055-.448.456-.793.97-1.035 1.567s-.38 1.197-.38 1.852.138 1.254.38 1.853.587 1.1 1.035 1.567 1.035.826 1.725 1.083c.656.257 1.45.4 2.312.4s1.656-.142 2.346-.4c.656-.256 1.242-.627 1.7-1.083s.828-.97 1.07-1.567.345-1.197.345-1.853zm11.9-4.503c.414-.712 1.07-1.34 2-1.852.897-.484 1.967-.74 3.2-.74 1.104 0 2.105.2 3.002.627.862.428 1.552 1.112 2.07 2.08.552-.883 1.3-1.54 2.312-2.024 1-.456 2.07-.684 3.243-.684 1.07 0 1.966.143 2.725.428.76.313 1.38.713 1.897 1.197a4.52 4.52 0 0 1 1.14 1.738c.243.655.345 1.368.345 2.138v8.38H92.84v-7.495a7.74 7.74 0 0 0-.172-1.568 3.36 3.36 0 0 0-.587-1.31 3.15 3.15 0 0 0-1.104-.912c-.45-.228-1.035-.342-1.76-.342s-1.38.114-1.897.37-.966.598-1.276.998a3.74 3.74 0 0 0-.725 1.396c-.172.513-.242 1.026-.242 1.568v7.296h-3.243v-8.04a6.15 6.15 0 0 0-.173-1.454c-.103-.427-.3-.826-.586-1.14a3.02 3.02 0 0 0-1.07-.74c-.448-.17-.966-.256-1.62-.256-1.207 0-2.174.4-2.967 1.197-.794.826-1.208 1.9-1.208 3.25v7.182h-3.243V13.016l-.034-1.396-.104-1.5h3.07l.103 1.14.034 1.083h.104z"/>
</svg></a>
    </div>
    <div class="ax-user">
      <a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target="_blank" rel="noopener nofollow" href="https://www.google.com/search?q=site:nullptr.ai" title="Search">
        <svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923l-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33 0 0 0 2.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg>

      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="/blog/">
        Blog
      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="/about/">
        About
      </a>
    </div>
  </div>

  
</header>

  <main>
<div class="default-single">
  <div class="ax-title ax-l-o">
    <div class="ax-l-i max-w-4xl">
      <h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">876. Middle of the Linked List</h1>
      <p class="post-subtitle font-content-sans font-light text-xl text-raven-500 mt-3">Solving the problem of finding the middle of a linked list in C++.</p>

      <div class="ax-meta flex items-center mt-5">
        <div class="flex-grow min-w-0">
          <div class="flex items-center">
  <div class="flex-shrink-0">
    <img
    class="w-12 h-12 sm:w-14 sm:h-14 object-cover p-3px rounded-full border border-blue-300"
    src="/image/brand/logo.svg"
    alt="Felix Pultar">
  </div>
  <div class="flex-shrink-0 ml-2 leading-tight font-content-sans">
    <a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target="_blank" rel="noopener nofollow" title="Felix Pultar" href="https://nullptr.ai/">Felix Pultar</a>
    <time class="text-sm text-raven-500" datetime="2023-01-23T12:00:00Z">Jan 23, 2023 1:00PM</time>
  </div>
</div>

        </div>
        <div>
          
        </div>
      </div>
    </div>
  </div><div class="ax-content ax-l-o">
    <div class="ax-l-i max-w-4xl">
      <article class="cdata">
<h2 id="the-problem-statement">The Problem Statement</h2>
<p>The problem is taken from <a href="https://leetcode.com/problems/middle-of-the-linked-list/description/">LeetCode</a>.</p>
<h2 id="first-solution-naïve-copy-to-stdvector">First Solution: Naïve Copy to std::vector</h2>
<p>The underlying problem here is that linked lists don't have random access. If the data structure we operate on were a <code>std::vector</code> or <code>std::array</code>, we could simply calculate the middle via the size of the container. So why don't we just copy all elements of the list into a <code>std::vector</code>?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * struct ListNode {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     int val;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode *next;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode() : val(0), next(nullptr) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode(int x) : val(x), next(nullptr) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> * };
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">middleNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// naive approach -&gt; copy to vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">elements</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>This approach has $O(n)$ run time complexity as we have to iterate once over the list and $O(n)$ space complexity as we copy each element into a <code>std::vector</code>. It's worth noting though that we only copy pointers and not the underlying data. In this particular case, the linked list stores <code>int</code> and accordingly, this difference does not change anything. However, it's conceivable that the linked list stores big objects (e.g. a 3D mesh), which we would <em>not</em> copy using this approach. In other words, it's potentially not as harmful to copy the data as the space complexity suggests. However, there is a better approach.</p>
<h2 id="two-pointer-running-technique">Two-Pointer Running Technique</h2>
<p>One way to avoid linear space complexity in this problem is the <strong>two-pointer running technique</strong>. We will instantiate two pointers named <code>slowRunner</code> and <code>fastRunner</code> that both initially point to the head node of the list. Subsequently, we will go through list once. In each iteration, <code>slowRunner</code> moves one node at a time and <code>fastRunner</code> moves two nodes at a time. Once <code>fastRunner</code> falls off the list, <code>slowRunner</code> points to the middle of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * struct ListNode {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     int val;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode *next;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode() : val(0), next(nullptr) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode(int x) : val(x), next(nullptr) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> * };
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">middleNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// two-pointer running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slowRunner</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">fastRunner</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">fastRunner</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">fastRunner</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">slowRunner</span> <span class="o">=</span> <span class="n">slowRunner</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">fastRunner</span> <span class="o">=</span> <span class="n">fastRunner</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">slowRunner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>This solution also has $O(n)$ run time complexity but only $O(1)$ space complexity.</p>

      </article>
      

      

    </div>
  </div>
</div>

  </main>
  <footer class="footer">
  <div class="ax-l-i max-w-6xl">
    <nav class="flex items-center justify-center">
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="/contact/">Contact</a>
    </nav>

    <div class="footer-copyright text-sm text-center text-gray-400 mt-4">
      &#169; 2023-2023 nullptr.ai
    </div>
    <div class="text-sm sm:text-xs text-center text-gray-400 mt-2">
      Powered by <a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral">Axiom</a> and Hugo
    </div>
  </div>
</footer>

<script src="/bundle.js?v=1703885521"></script>


</body>
</html>
